
<!DOCTYPE html>
<!-- Indica al navegador que aquest document √©s HTML5 -->
<html lang="ca">
  <!-- L'atribut "lang" especifica que el contingut est√† en catal√† -->

  <head>
    <!-- La secci√≥ <head> cont√© metadades, enlla√ßos a scripts i definicions d'estils -->
    
    <meta charset="UTF-8">
    <!-- Defineix la codificaci√≥ de car√†cters com UTF-8, assegurant la correcta visualitzaci√≥ de tots els s√≠mbols -->

    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- Defineix el viewport perqu√® la p√†gina s'adapti a dispositius m√≤bils:
         - width=device-width: l'amplada coincideix amb la de l'aparell
         - initial-scale=1.0: escala inicial de 100% -->

    <title>Art Facial Responsiu - Transicions Suaves i Fons Din√†mic</title>
    <!-- Estableix el t√≠tol de la p√†gina, que apareixer√† a la pestanya del navegador -->

    <!-- Carrega la biblioteca p5.js per al dibuix interactiu i la gesti√≥ del canvas -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.11.3/p5.js"></script>
    <!-- Carrega la biblioteca ml5.js, que cont√© models de machine learning com la detecci√≥ facial -->

    <script src="https://cdn.jsdelivr.net/gh/ml5js/Intro-ML-Arts-IMA@ml5-build-10-7-19/ml5_build/ml5.min.js"></script>
    <!-- Aquest script carrega ml5.js en una versi√≥ compilada, utilitzada per la detecci√≥ facial -->

    <style>
      /*--------------------------------------------------
      ESTILS PER A TOTA LA P√ÄGINA
      --------------------------------------------------*/
      body {
        margin: 0;         /* Elimina els marges per utilitzar tota la finestra */
        padding: 0;        /* Tamb√© elimina qualsevol farcit (padding) per defecte */
        overflow: hidden;  /* Evita que apareguin barres de despla√ßament si algun element surt de la finestra */
        background: #f0f0f0;/* Estableix un fons gris molt clar; "f0f0f0" √©s un to suau de gris */
      }

      /*--------------------------------------------------
      ESTILS PER A LA PANTALLA DE C√ÄRREGA (LOADING SCREEN)
      --------------------------------------------------*/
      #loading-screen {
        position: fixed;   /* L'element es mant√© fix a la finestra, sense moure's amb el despla√ßament */
        top: 0;            /* S'ubica a la part superior de la finestra */
        left: 0;           /* S'ubica a la cantonada esquerra */
        width: 100%;       /* Ocupa tot l'amplada de la finestra */
        height: 100%;      /* Ocupa tota l'altura de la finestra */
        background: rgba(255,255,255,0.95);
        /* Defineix un fons blanc amb una opacitat lleugerament inferior al 100% (0.95) */
        display: flex;     /* Utilitza Flexbox per alinear els elements dins del contenidor */
        flex-direction: column; /* Organitza els elements verticalment (en columna) */
        justify-content: center; /* Centra els elements verticalment dins del contenidor */
        align-items: center;     /* Centra els elements horitzontalment */
        font-family: Arial, sans-serif; /* Defineix la font del text: Arial com a principal i altres sans-serif si Arial no est√† disponible */
        z-index: 1000;     /* Assegura que aquest element aparegui per sobre de tot el contingut de la p√†gina */
      }

      /*--------------------------------------------------
      ESTILS PER AL CERCLE GIRATORI (LOADER)
      --------------------------------------------------*/
      .loader {
        width: 40px;           /* Amplada de 40 p√≠xels */
        height: 40px;          /* Al√ßada de 40 p√≠xels per obtenir un quadrat */
        border: 5px solid #3498db;
        /* Aplica un contorn de 5 p√≠xels d'amplada amb un color blau (hexadecimal #3498db) */
        border-top-color: transparent;
        /* Defineix que la part superior del contorn sigui transparent per crear l'efecte de gir */
        border-radius: 50%;    /* Arrodoneix les cantonades per transformar l'element en un cercle */
        animation: spin 1s linear infinite;
        /* Assigna l'animaci√≥ "spin":
             - Durada: 1 segon
             - Tipus: linear (moviment constant)
             - Iteraci√≥: infinite, √©s a dir, es repeteix indefinidament */
      }

      /*--------------------------------------------------
      ANIMACI√ì PER GIRAR EL CERCLE
      --------------------------------------------------*/
      @keyframes spin {
        to { transform: rotate(360deg); }
        /* La transformaci√≥ final √©s una rotaci√≥ completa de 360 graus */
      }

      /*--------------------------------------------------
      ESTILS PER ALS PAR√ÄGRAFS DINS DEL LOADING SCREEN
      --------------------------------------------------*/
      #loading-screen p {
        margin-top: 15px;    /* Afegeix un espai de 15 p√≠xels per sobre del par√†graf */
        font-size: 1.1em;    /* Defineix la mida del text com 1.1 vegades la mida base del navegador */
        color: #333;         /* Estableix el color del text com un gris fosc ("#333") */
      }
    </style>
  </head>

  <body>
    <!--
      Contingut visible de la p√†gina. Aqu√≠ mostrarem primer la pantalla de c√†rrega,
      que despr√©s s'amagar√† quan es carreguin els models.
    -->
    <div id="loading-screen">
      <!-- Aquest element cont√© el cercle giratori -->
      <div class="loader"></div>
      <!-- I un missatge per informar a l'usuari que es carreguen els models -->
      <p>Carregant models...</p>
    </div>

    <script>
      //--------------------------------------------------
      // VARIABLES GLOBALES
      //--------------------------------------------------
      let faceapi, detections = [], video;
      // "faceapi" ser√† l'objecte que ens gestionar√† la detecci√≥ facial.
      // "detections" √©s una matriu (array) que emmagatzemar√† les deteccions facials.
      // "video" guardar√† el flux de v√≠deo capturat des de la c√†mera.
      
      let modelsReady = false;
      // Variable booleana que indicar√† si els models han estat carregats correctament (comen√ßa en false).

      let currentExpression = { dominant: 'neutral', intensity: 0 };
      // Objecte que emmagatzema l'expressi√≥ facial actual:
      // "dominant" indica l'expressi√≥ m√©s marcada (inicialment "neutral")
      // "intensity" indica la intensitat de l'expressi√≥ (valors entre 0 i 1).

      // Variable per a una transici√≥ suau de la intensitat detectada
      let smoothIntensity = 0;
      // Aix√≤ permet interpolar suaument entre l'estat anterior i el nou.

      //--------------------------------------------------
      // VARIABLES PER AL FONS ‚Äì GRADIENT DIN√ÄMIC
      //--------------------------------------------------
      let currentGradientStart, currentGradientEnd;
      // Colors actius per al gradient actual del fons.

      let targetGradientStart, targetGradientEnd;
      // Colors objectiu per al gradient, segons l‚Äôemoci√≥ detectada; s'interpolaran fins aconseguir la transici√≥ suau.

      //--------------------------------------------------
      // FUNCI√ì PER OBTINDRE ELS COLORS DEL GRADIENT
      //--------------------------------------------------
      function getGradientForEmotion(emotion) {
        // Aquesta funci√≥ rep com a par√†metre l'emoci√≥ i retorna un objecte amb dos colors: start i end.
        switch (emotion) {
          case 'happy':
            return { start: color(255, 223, 186), end: color(255, 183, 77) };
            // Per l'emoci√≥ "happy", s'utilitzen tons c√†lids i suaus (taronges i taronja clar).
          case 'sad':
            return { start: color(173, 216, 230), end: color(100, 149, 237) };
            // Per "sad", es trien tons blaus que evoquen tranquil¬∑litat o tristesa.
          case 'angry':
            return { start: color(255, 160, 122), end: color(255, 69, 0) };
            // Per "angry", tons vermells i taronges intensos, que denoten passi√≥ o agressivitat.
          case 'disgusted':
            return { start: color(144, 238, 144), end: color(34, 139, 34) };
            // Per "disgusted", s'utilitzen tons verds que poden evocar repulsi√≥.
          case 'surprised':
            return { start: color(216, 191, 216), end: color(147, 112, 219) };
            // Per "surprised", colors suaus lil√†s o malva per evocar sorpresa.
          default:
            return { start: color(240, 240, 240), end: color(200, 200, 200) };
            // Per qualsevol altra emoci√≥ (incloent "neutral"), s'utilitzen tons grisos.
        }
      }

      //--------------------------------------------------
      // FUNCI√ì PER DIBUIXAR UN GRADIENT VERTICAL
      //--------------------------------------------------
      function setGradient(x, y, w, h, c1, c2, axis = 'y') {
        // Aquesta funci√≥ pinta un gradient dins d'un rectangle definit per la posici√≥ (x,y) i dimensions (w, h).
        // "c1" i "c2" s√≥n els colors inicial i final.
        // "axis" indica si el gradient √©s vertical ('y') o horitzontal ('x'); per defecte √©s vertical.
        noFill();    // No omplim cap forma, ja que pintarem l√≠nia per l√≠nia.
        if (axis === 'y') {  // Si el gradient √©s vertical...
          for (let i = y; i <= y + h; i++) {
            // Per cada fila en el rectangle...
            let inter = map(i, y, y + h, 0, 1);
            // Interpola un valor entre 0 i 1 depenent de la posici√≥ actual.
            let c = lerpColor(c1, c2, inter);
            // Calcula el color intermig fent una interpolaci√≥ (lerp) entre c1 i c2 basat en "inter".
            stroke(c); 
            // Defineix el color de la l√≠nia amb el color calculat.
            line(x, i, x + w, i);
            // Dibuixa una l√≠nia horitzontal per l'altura corresponent.
          }
        } else if (axis === 'x') { // Si el gradient √©s horitzontal...
          for (let i = x; i <= x + w; i++) {
            let inter = map(i, x, x + w, 0, 1);
            let c = lerpColor(c1, c2, inter);
            stroke(c);
            line(i, y, i, y + h);
            // Dibuixa l√≠nies verticals per cada posici√≥ (x) que formen el gradient horitzontal.
          }
        }
      }

      //--------------------------------------------------
      // FUNCI√ì SETUP (p5.js)
      //--------------------------------------------------
      function setup() {
        // Aquesta funci√≥ s'executa una sola vegada quan la p√†gina es carrega.
        createCanvas(windowWidth, windowHeight);
        // Crea el canvas de p5.js amb l'amplada i al√ßada iguals a la finestra.

        // Establim el gradient inicial segons l'emoci√≥ "neutral"
        let neutralGrad = getGradientForEmotion('neutral');
        currentGradientStart = neutralGrad.start; // Color de comen√ßament del gradient
        currentGradientEnd = neutralGrad.end;     // Color final del gradient

        // CONFIGURACI√ì DEL V√çDEO:
        video = createCapture(VIDEO);
        // Inicia la captura del v√≠deo utilitzant la c√†mera del dispositiu.
        video.size(320, 240);
        // Defineix una mida inicial per al v√≠deo.
        video.hide();
        // Amaga l'element HTML del v√≠deo ja que el dibuix es realitza al canvas.
        video.elt.muted = true;
        // Assegura que el v√≠deo no emeti so.
        video.elt.playsinline = true;
        // Permet que el v√≠deo es reprodueixi "in-line", principalment en dispositius m√≤bils.

        // OPCIONS PER AL MODEL FACIAL:
        const options = {
          withLandmarks: true,    /* Detecta punts de refer√®ncia facials (ulls, nas, boca, etc.) */
          withExpressions: true,  /* Detecta expressions facials (com happy, sad, angry, etc.) */
          withDescriptors: false  /* No es necessita informaci√≥ addicional com descriptors en aquest exemple */
        };

        // INICIALITZACI√ì DE faceapi
        faceapi = ml5.faceApi(video, options, () => {
          // Aquesta funci√≥ callback s'executa quan el model ha estat carregat correctament.
          modelsReady = true;  // Marquem que els models estan preparats.
          // Amaguem la pantalla de c√†rrega perqu√® el model ja est√† llest.
          document.getElementById('loading-screen').style.display = 'none';
          // Inicia la detecci√≥ facial, passant la funci√≥ gotResults com a callback per rebre resultats.
          faceapi.detect(gotResults);
        });
      }

      //--------------------------------------------------
      // FUNCI√ì windowResized (p5.js)
      //--------------------------------------------------
      function windowResized() {
        // Aquesta funci√≥ s'executa cada cop que la finestra redimensiona.
        resizeCanvas(windowWidth, windowHeight);
        // Ajusta el canvas a la nova mida de la finestra.
        video.size(max(160, width / 4), max(120, height / 4));
        // Tamb√© redimensiona la c√†mera, assegurant un m√≠nim perqu√® el v√≠deo no es faci massa petit.
      }

      //--------------------------------------------------
      // FUNCI√ì gotResults - Callback de detecci√≥ facial
      //--------------------------------------------------
      function gotResults(err, results) {
        // Aquesta funci√≥ s'executa cada cop que ml5.faceApi retorna resultats.
        if (err) {
          // En cas d'error, imprimeix-lo a la consola.
          console.error(err);
          // Mostra un missatge d'error en la pantalla de c√†rrega indicant un problema amb la c√†mera.
          document.getElementById('loading-screen').innerHTML =
            '<p style="color: red">Error! Comprova la c√†mera i actualitza.</p>';
          return;
          // Finalitza l'execuci√≥ de la funci√≥ en cas d'error.
        }
        // Guarda les deteccions en la variable global "detections".
        detections = results;
        // Si hi ha deteccions (almenys una cara detectada), actualitza l'expressi√≥ actual.
        if (detections.length > 0) updateCurrentExpression();
        // Torna a cridar la detecci√≥ facial per obtenir resultats cont√≠nus.
        faceapi.detect(gotResults);
      }

      //--------------------------------------------------
      // FUNCI√ì updateCurrentExpression
      //--------------------------------------------------
      function updateCurrentExpression() {
        // Aquesta funci√≥ recorre totes les deteccions facials i actualitza l'expressi√≥ dominant.
        let maxIntensity = 0; // Inicialitza la intensitat m√†xima trobada en 0.
        detections.forEach(face => {
          // Per cadascuna de les cares detectades...
          const expr = face.expressions;
          // "expr" cont√© un objecte amb les diferents expressions detectades i la seva intensitat.
          const dominant = Object.keys(expr).reduce((a, b) => expr[a] > expr[b] ? a : b);
          // Determina quina expressi√≥ t√© la intensitat m√©s alta utilitzant reduce.
          if (expr[dominant] > maxIntensity) {
            // Si la intensitat de l'expressi√≥ dominant √©s m√©s gran que la m√†xima trobada...
            currentExpression = {
              dominant: dominant,
              intensity: expr[dominant]
            };
            // Actualitza l'objecte currentExpression amb el nom i la intensitat de l'expressi√≥ dominant.
            maxIntensity = expr[dominant];
            // Actualitza el valor m√†xim per comparar en futures deteccions.
          }
        });
        // Actualitza els colors del gradient objectiu segons l'emoci√≥ dominant detectada.
        let grad = getGradientForEmotion(currentExpression.dominant);
        targetGradientStart = grad.start;
        targetGradientEnd = grad.end;
      }

      //--------------------------------------------------
      // FUNCI√ì draw (p5.js)
      //--------------------------------------------------
      function draw() {
        // Aquesta funci√≥ s'executa constantment (frame per frame) per actualitzar el dibuix.
        
        // Interpolaci√≥ suau de l'intensitat: actualitza smoothIntensity per aconseguir una transici√≥ fluida.
        smoothIntensity = lerp(smoothIntensity, currentExpression.intensity, 0.1);

        // Actualitzaci√≥ suau dels colors del gradient:
        if (targetGradientStart && targetGradientEnd) {
          // Si els colors objectiu han estat definits...
          currentGradientStart = lerpColor(currentGradientStart, targetGradientStart, 0.1);
          // Interpola el color de comen√ßament del gradient cap a l'objectiu.
          currentGradientEnd = lerpColor(currentGradientEnd, targetGradientEnd, 0.1);
          // Interpola el color final del gradient de manera similar.
        }

        // Dibuixa el fons din√†mic pintant un gradient vertical que cobreix tot el canvas.
        setGradient(0, 0, width, height, currentGradientStart, currentGradientEnd, 'y');

        // Dibuixa l'art interactiu al centre del canvas:
        push();
        // Guarda l'estat actual del context gr√†fic.
        translate(width / 2, height / 2);
        // Trasllada el sistema de coordenades perqu√® (0,0) sigui el centre de la finestra.
        const scaleFactor = min(width, height) / 800;
        // Calcula un factor d'escala per adaptar els dibuixos a la mida de la finestra.
        scale(scaleFactor);
        // Aplica l'escala calculada.
        drawArt();
        // Crida la funci√≥ que dibuixa l'art segons l'expressi√≥ facial.
        pop();
        // Restaura l'estat inicial del context gr√†fic, per no afectar altres dibuixos.

        // Dibuixa la interf√≠cie (HUD) amb informaci√≥ textual (emoticon i percentatge).
        drawHUD();
        // Dibuixa una previsualitzaci√≥ petita del v√≠deo en una cantonada.
        drawVideoPreview();
      }

      //--------------------------------------------------
      // FUNCI√ì drawArt
      //--------------------------------------------------
      function drawArt() {
        // Aquesta funci√≥ dibuixa formes art√≠stiques basades en l'expressi√≥ facial detectada.
        const { dominant, intensity } = currentExpression;
        // Extreu la clau "dominant" de l'objecte currentExpression (indicant l'emoci√≥ m√©s forta).
        const t = frameCount * 0.05;
        // "t" √©s una variable que canvia amb el temps per animar els moviments, depenent del nombre de frames.
        const centerX = width/2;
        const centerY = height/2;
        // Com que hem traslladat el sistema de coordenades al centre, (0,0) √©s el centre.
        const baseSize = 200 * smoothIntensity;
        // Defineix una mida base per al dibuix que dep√®n de la intensitat suau interpolada.
        strokeWeight(map(smoothIntensity, 0, 1, 1, 4));
        // Estableix el gruix de la l√≠nia variant entre 1 i 4 p√≠xels en funci√≥ de la intensitat.
        noFill();
        // Per defecte, no omple les formes tret que s'indiqui.

        // Utilitza un "switch" per determinar quina forma dibuixar segons l'expressi√≥ dominant.
        switch (dominant) {

          case 'happy':
            // Cas per a l'emoci√≥ "happy" (feli√ß)
          push();
            translate(widht/2,height/2);
            stroke(255, 204, 0);
            // Defineix que el contorn sigui de color groc (RGB: 255, 204, 0)
            fill(255, 230, 100, 150 * smoothIntensity);
            // Omple la forma amb un groc clar. El valor 150 * smoothIntensity controla la transpar√®ncia
           beginShape();//Ojo izquierdo
vertex(138, 201.1875);
vertex(140, 196.1875);
vertex(143, 193.1875);
vertex(149, 193.1875);
vertex(154, 195.1875);
vertex(158, 198.1875);
vertex(161, 204.1875);
vertex(154, 205.1875);
vertex(148, 206.1875);
vertex(142, 206.1875);
vertex(137, 202.1875);
endShape(CLOSE);
          fill(255, 250, 239);
          beginShape();//Ojo derecho
vertex(191, 211.1875);
vertex(197, 216.1875);
vertex(206, 220.1875);
vertex(217, 221.1875);
vertex(222, 219.1875);
vertex(225, 210.1875);
vertex(217, 205.1875);
vertex(211, 202.1875);
vertex(205, 202.1875);
vertex(198, 203.1875);
vertex(193, 208.1875);
  endShape(CLOSE);  
          fill(255, 250, 239)
          beginShape();//Nariz
vertex(186, 266.1875);
vertex(176, 266.1875);
vertex(167, 264.1875);
vertex(160, 261.1875);
vertex(156, 258.1875);
vertex(153, 255.1875);
vertex(154, 253.1875);
vertex(157, 247.1875);
vertex(159, 240.1875);
vertex(162, 235.1875);
vertex(163, 227.1875);
vertex(164, 220.1875);
vertex(164, 213.1875);
vertex(163, 207.1875);
vertex(162, 200.1875);
vertex(161, 194.1875);
vertex(160, 189.1875);
vertex(156, 184.1875);
endShape(CLOSE);
          beginShape();//Silueta cara
vertex(139, 188.1875);
vertex(136, 183.1875);
vertex(135, 178.1875);
vertex(137, 172.1875);
vertex(140, 165.1875);
vertex(143, 159.1875);
vertex(146, 152.1875);
vertex(150, 148.1875);
vertex(154, 144.1875);
vertex(160, 142.1875);
vertex(166, 142.1875);
vertex(174, 143.1875);
vertex(183, 146.1875);
vertex(191, 150.1875);
vertex(198, 153.1875);
vertex(208, 158.1875);
vertex(217, 163.1875);
vertex(220, 167.1875);
vertex(227, 170.1875);
vertex(235, 175.1875);
vertex(243, 182.1875);
vertex(251, 188.1875);
vertex(259, 199.1875);
vertex(268, 206.1875);
vertex(275, 213.1875);
vertex(280, 219.1875);
vertex(286, 226.1875);
vertex(294, 232.1875);
vertex(299, 238.1875);
vertex(295, 245.1875);
vertex(291, 251.1875);
vertex(286, 258.1875);
vertex(284, 263.1875);
vertex(285, 269.1875);
vertex(287, 275.1875);
vertex(291, 276.1875);
vertex(296, 278.1875);
vertex(296, 285.1875);
vertex(295, 291.1875);
vertex(287, 298.1875);
vertex(273, 307.1875);
vertex(255, 318.1875);
vertex(244, 323.1875);
vertex(229, 330.1875);
vertex(220, 331.1875);
vertex(208, 332.1875);
vertex(200, 335.1875);
vertex(186, 337.1875);
vertex(176, 333.1875);
vertex(167, 331.1875);
vertex(159, 324.1875);
vertex(156, 316.1875);
vertex(153, 309.1875);
vertex(151, 302.1875);
vertex(147, 293.1875);
vertex(142, 283.1875);
vertex(140, 275.1875);
vertex(137, 262.1875);
vertex(135, 251.1875);
vertex(133, 244.1875);
vertex(133, 234.1875);
vertex(133, 221.1875);
vertex(134, 212.1875);
vertex(137, 205.1875);
endShape(CLOSE);
          beginShape();//Labio inferior
vertex(155, 287.1875);
vertex(152, 292.1875);
vertex(152, 296.1875);
vertex(153, 300.1875);
vertex(158, 303.1875);
vertex(166, 307.1875);
vertex(174, 310.1875);
vertex(181, 307.1875);
vertex(188, 304.1875);
vertex(194, 302.1875);
vertex(202, 297.1875);
vertex(197, 294.1875);
vertex(194, 295.1875);
vertex(186, 297.1875);
vertex(178, 297.1875);
vertex(170, 296.1875);
vertex(164, 292.1875);
vertex(160, 289.1875);
vertex(156, 286.1875);
endShape(CLOSE);
          beginShape();//Labio superior
vertex(198, 295.1875);
vertex(190, 295.1875);
vertex(180, 295.1875);
vertex(171, 294.1875);
vertex(163, 292.1875);
vertex(158, 289.1875);
vertex(153, 286.1875);
vertex(150, 283.1875);
vertex(155, 281.1875);
vertex(159, 281.1875);
vertex(167, 281.1875);
vertex(173, 284.1875);
vertex(178, 286.1875);
vertex(184, 289.1875);
vertex(189, 290.1875);
vertex(192, 291.1875);
vertex(197, 293.1875);
vertex(199, 293.1875);
          endShape(CLOSE);
          beginShape();//Silueta accesorio pelo
vertex(319, 254.1875);
vertex(293, 231.1875);
vertex(270, 206.1875);
vertex(247, 183.1875);
vertex(215, 162.1875);
vertex(188, 148.1875);
vertex(164, 141.1875);
vertex(155, 144.1875);
vertex(149, 149.1875);
vertex(144, 145.1875);
vertex(146, 135.1875);
vertex(150, 126.1875);
vertex(157, 114.1875);
vertex(165, 104.1875);
vertex(172, 96.1875);
vertex(183, 87.1875);
vertex(195, 81.1875);
vertex(205, 78.1875);
vertex(214, 75.1875);
vertex(222, 74.1875);
vertex(230, 71.1875);
vertex(240, 71.1875);
vertex(259, 74.1875);
vertex(280, 78.1875);
vertex(297, 86.1875);
vertex(309, 95.1875);
vertex(319, 102.1875);
vertex(334, 115.1875);
vertex(345, 127.1875);
vertex(351, 137.1875);
vertex(359, 145.1875);
vertex(360, 164.1875);
vertex(359, 176.1875);
vertex(355, 186.1875);
vertex(350, 206.1875);
vertex(351, 212.1875);
vertex(351, 212.1875);
vertex(351, 228.1875);
vertex(351, 240.1875);
vertex(342, 246.1875);
vertex(334, 254.1875);
vertex(328, 257.1875);
vertex(319, 256.1875);
            endShape(CLOSE);
          beginShape();//Tronco superior
vertex(130, 582.1875);
vertex(141, 552.1875);
vertex(156, 524.1875);
vertex(164, 501.1875);
vertex(184, 476.1875);
vertex(181, 466.1875);
vertex(179, 455.1875);
vertex(179, 455.1875);
vertex(182, 447.1875);
vertex(187, 433.1875);
vertex(195, 423.1875);
vertex(199, 414.1875);
vertex(203, 404.1875);
vertex(211, 400.1875);
vertex(216, 390.1875);
vertex(227, 382.1875);
vertex(235, 375.1875);
vertex(250, 367.1875);
vertex(262, 359.1875);
vertex(269, 358.1875);
vertex(273, 354.1875);
vertex(284, 350.1875);
vertex(295, 346.1875);
vertex(306, 342.1875);
vertex(319, 339.1875);
vertex(336, 334.1875);
vertex(349, 331.1875);
vertex(359, 331.1875);
vertex(371, 335.1875);
vertex(375, 360.1875);
vertex(379, 403.1875);
vertex(378, 429.1875);
vertex(380, 448.1875);
vertex(379, 462.1875);
vertex(394, 467.1875);
vertex(395, 485.1875);
vertex(398, 504.1875);
vertex(405, 515.1875);
vertex(414, 533.1875);
vertex(414, 553.1875);
vertex(411, 561.1875);
vertex(413, 568.1875);
vertex(416, 583.1875);
           endShape(CLOSE);
          beginShape();//Pendiente
vertex(298, 279.1875);
vertex(295, 289.1875);
vertex(290, 299.1875);
vertex(287, 309.1875);
vertex(291, 315.1875);
vertex(294, 318.1875);
vertex(300, 319.1875);
vertex(305, 318.1875);
vertex(310, 315.1875);
vertex(312, 306.1875);
vertex(311, 299.1875);
vertex(309, 293.1875);
vertex(303, 288.1875);
vertex(299, 281.1875);
            endShape(CLOSE);
            beginShape();//Cuello
vertex(225, 357.1875);
vertex(220, 348.1875);
vertex(216, 340.1875);
vertex(213, 333.1875);
vertex(221, 333.1875);
vertex(231, 332.1875);
vertex(247, 326.1875);
vertex(261, 317.1875);
vertex(261, 317.1875);
vertex(270, 312.1875);
vertex(273, 306.1875);
vertex(278, 300.1875);
vertex(281, 295.1875);
vertex(283, 290.1875);
vertex(287, 280.1875);
vertex(289, 291.1875);
vertex(288, 300.1875);
vertex(288, 305.1875);
vertex(291, 309.1875);
vertex(289, 317.1875);
vertex(292, 319.1875);
vertex(295, 321.1875);
vertex(297, 325.1875);
vertex(284, 330.1875);
vertex(265, 335.1875);
vertex(250, 341.1875);
vertex(236, 350.1875);
vertex(233, 354.1875);
vertex(226, 356.1875);
endShape(CLOSE);
            beginShape();//Oreja
vertex(302, 239.1875);
vertex(296, 254.1875);
vertex(289, 267.1875);
vertex(289, 274.1875);
vertex(294, 275.1875);
vertex(304, 273.1875);
vertex(312, 267.1875);
vertex(316, 258.1875);
vertex(312, 250.1875);
vertex(302, 238.1875);
endShape(CLOSE);
            // Tanca la forma, connectant el darrer vertex amb el primer per completar el contorn
            break;
            pop();

          case 'sad':
            // Cas per a l'emoci√≥ "sad" (trist)
            stroke(70, 130, 230);
            // Contorn amb un to blau moderat (RGB: 70, 130, 230)
            fill(100, 180, 255, 100 * smoothIntensity);
            // Omple la figura amb un blau m√©s clar i transpar√®ncia segons la intensitat
             beginShape();//Ojo derecho
          vertex(191, 211.1875);
vertex(197, 216.1875);
vertex(206, 220.1875);
vertex(217, 221.1875);
vertex(222, 219.1875);
vertex(225, 210.1875);
vertex(217, 205.1875);
vertex(211, 202.1875);
vertex(205, 202.1875);
vertex(198, 203.1875);
vertex(193, 208.1875);
endShape(CLOSE);
          beginShape();//Ojo izquierdo
vertex(138, 201.1875);
vertex(140, 196.1875);
vertex(143, 193.1875);
vertex(149, 193.1875);
vertex(154, 195.1875);
vertex(158, 198.1875);
vertex(161, 204.1875);
vertex(154, 205.1875);
vertex(148, 206.1875);
vertex(142, 206.1875);
vertex(137, 202.1875);
endShape(CLOSE);
          beginShape();//Nariz
vertex(186, 266.1875);
vertex(176, 266.1875);
vertex(167, 264.1875);
vertex(160, 261.1875);
vertex(156, 258.1875);
vertex(153, 255.1875);
vertex(154, 253.1875);
vertex(157, 247.1875);
vertex(159, 240.1875);
vertex(162, 235.1875);
vertex(163, 227.1875);
vertex(164, 220.1875);
vertex(164, 213.1875);
vertex(163, 207.1875);
vertex(162, 200.1875);
vertex(161, 194.1875);
vertex(160, 189.1875);
vertex(156, 184.1875);
endShape(CLOSE);
          beginShape();//Labio inferior cara triste
vertex(208, 302.1875);
vertex(200, 298.1875);
vertex(190, 298.1875);
vertex(180, 299.1875);
vertex(171, 298.1875);
vertex(162, 295.1875);
vertex(159, 288.1875);
vertex(153, 286.1875);
vertex(153, 294.1875);
vertex(158, 305.1875);
vertex(166, 308.1875);
vertex(174, 308.1875);
vertex(187, 303.1875);
vertex(189, 303.1875);
vertex(195, 300.1875);
vertex(200, 299.1875);
endShape(CLOSE);
          beginShape();//Labio superior cara triste
vertex(193, 295.1875);
vertex(189, 295.1875);
vertex(182, 294.1875);
vertex(182, 294.1875);
vertex(171, 291.1875);
vertex(165, 290.1875);
vertex(160, 288.1875);
vertex(155, 287.1875);
vertex(153, 287.1875);
vertex(150, 284.1875);
vertex(151, 281.1875);
vertex(157, 282.1875);
vertex(165, 280.1875);
vertex(173, 285.1875);
vertex(181, 288.1875);
vertex(188, 289.1875);
vertex(195, 292.1875);
vertex(197, 294.1875);
vertex(194, 295.1875);
endShape(CLOSE);
          beginShape();//Silueta cara
vertex(139, 188.1875);
vertex(136, 183.1875);
vertex(135, 178.1875);
vertex(137, 172.1875);
vertex(140, 165.1875);
vertex(143, 159.1875);
vertex(146, 152.1875);
vertex(150, 148.1875);
vertex(154, 144.1875);
vertex(160, 142.1875);
vertex(166, 142.1875);
vertex(174, 143.1875);
vertex(183, 146.1875);
vertex(191, 150.1875);
vertex(198, 153.1875);
vertex(208, 158.1875);
vertex(217, 163.1875);
vertex(220, 167.1875);
vertex(227, 170.1875);
vertex(235, 175.1875);
vertex(243, 182.1875);
vertex(251, 188.1875);
vertex(259, 199.1875);
vertex(268, 206.1875);
vertex(275, 213.1875);
vertex(280, 219.1875);
vertex(286, 226.1875);
vertex(294, 232.1875);
vertex(299, 238.1875);
vertex(295, 245.1875);
vertex(291, 251.1875);
vertex(286, 258.1875);
vertex(284, 263.1875);
vertex(285, 269.1875);
vertex(287, 275.1875);
vertex(291, 276.1875);
vertex(296, 278.1875);
vertex(296, 285.1875);
vertex(295, 291.1875);
vertex(287, 298.1875);
vertex(273, 307.1875);
vertex(255, 318.1875);
vertex(244, 323.1875);
vertex(229, 330.1875);
vertex(220, 331.1875);
vertex(208, 332.1875);
vertex(200, 335.1875);
vertex(186, 337.1875);
vertex(176, 333.1875);
vertex(167, 331.1875);
vertex(159, 324.1875);
vertex(156, 316.1875);
vertex(153, 309.1875);
vertex(151, 302.1875);
vertex(147, 293.1875);
vertex(142, 283.1875);
vertex(140, 275.1875);
vertex(137, 262.1875);
vertex(135, 251.1875);
vertex(133, 244.1875);
vertex(133, 234.1875);
vertex(133, 221.1875);
vertex(134, 212.1875);
vertex(137, 205.1875);
endShape(CLOSE);
          beginShape();//Silueta accesorio pelo
vertex(319, 254.1875);
vertex(293, 231.1875);
vertex(270, 206.1875);
vertex(247, 183.1875);
vertex(215, 162.1875);
vertex(188, 148.1875);
vertex(164, 141.1875);
vertex(155, 144.1875);
vertex(149, 149.1875);
vertex(144, 145.1875);
vertex(146, 135.1875);
vertex(150, 126.1875);
vertex(157, 114.1875);
vertex(165, 104.1875);
vertex(172, 96.1875);
vertex(183, 87.1875);
vertex(195, 81.1875);
vertex(205, 78.1875);
vertex(214, 75.1875);
vertex(222, 74.1875);
vertex(230, 71.1875);
vertex(240, 71.1875);
vertex(259, 74.1875);
vertex(280, 78.1875);
vertex(297, 86.1875);
vertex(309, 95.1875);
vertex(319, 102.1875);
vertex(334, 115.1875);
vertex(345, 127.1875);
vertex(351, 137.1875);
vertex(359, 145.1875);
vertex(360, 164.1875);
vertex(359, 176.1875);
vertex(355, 186.1875);
vertex(350, 206.1875);
vertex(351, 212.1875);
vertex(351, 212.1875);
vertex(351, 228.1875);
vertex(351, 240.1875);
vertex(342, 246.1875);
vertex(334, 254.1875);
vertex(328, 257.1875);
vertex(319, 256.1875);
           endShape(CLOSE);
           beginShape();//Tronco superior
vertex(130, 582.1875);
vertex(141, 552.1875);
vertex(156, 524.1875);
vertex(164, 501.1875);
vertex(184, 476.1875);
vertex(181, 466.1875);
vertex(179, 455.1875);
vertex(179, 455.1875);
vertex(182, 447.1875);
vertex(187, 433.1875);
vertex(195, 423.1875);
vertex(199, 414.1875);
vertex(203, 404.1875);
vertex(211, 400.1875);
vertex(216, 390.1875);
vertex(227, 382.1875);
vertex(235, 375.1875);
vertex(250, 367.1875);
vertex(262, 359.1875);
vertex(269, 358.1875);
vertex(273, 354.1875);
vertex(284, 350.1875);
vertex(295, 346.1875);
vertex(306, 342.1875);
vertex(319, 339.1875);
vertex(336, 334.1875);
vertex(349, 331.1875);
vertex(359, 331.1875);
vertex(371, 335.1875);
vertex(375, 360.1875);
vertex(379, 403.1875);
vertex(378, 429.1875);
vertex(380, 448.1875);
vertex(379, 462.1875);
vertex(394, 467.1875);
vertex(395, 485.1875);
vertex(398, 504.1875);
vertex(405, 515.1875);
vertex(414, 533.1875);
vertex(414, 553.1875);
vertex(411, 561.1875);
vertex(413, 568.1875);
vertex(416, 583.1875);
           endShape(CLOSE);
          beginShape();//Pendiente
vertex(298, 279.1875);
vertex(295, 289.1875);
vertex(290, 299.1875);
vertex(287, 309.1875);
vertex(291, 315.1875);
vertex(294, 318.1875);
vertex(300, 319.1875);
vertex(305, 318.1875);
vertex(310, 315.1875);
vertex(312, 306.1875);
vertex(311, 299.1875);
vertex(309, 293.1875);
vertex(303, 288.1875);
vertex(299, 281.1875);
          endShape(CLOSE);
            beginShape();//Cuello
vertex(225, 357.1875);
vertex(220, 348.1875);
vertex(216, 340.1875);
vertex(213, 333.1875);
vertex(221, 333.1875);
vertex(231, 332.1875);
vertex(247, 326.1875);
vertex(261, 317.1875);
vertex(261, 317.1875);
vertex(270, 312.1875);
vertex(273, 306.1875);
vertex(278, 300.1875);
vertex(281, 295.1875);
vertex(283, 290.1875);
vertex(287, 280.1875);
vertex(289, 291.1875);
vertex(288, 300.1875);
vertex(288, 305.1875);
vertex(291, 309.1875);
vertex(289, 317.1875);
vertex(292, 319.1875);
vertex(295, 321.1875);
vertex(297, 325.1875);
vertex(284, 330.1875);
vertex(265, 335.1875);
vertex(250, 341.1875);
vertex(236, 350.1875);
vertex(233, 354.1875);
vertex(226, 356.1875);
endShape(CLOSE);
            beginShape();//tela que hace de pelo
vertex(255, 56.1875);
vertex(271, 53.1875);
vertex(295, 57.1875);
vertex(317, 67.1875);
vertex(339, 82.1875);
vertex(356, 98.1875);
vertex(358, 117.1875);
vertex(355, 122.1875);
vertex(358, 128.1875);
vertex(357, 139.1875);
vertex(344, 125.1875);
vertex(328, 110.1875);
vertex(313, 98.1875);
vertex(300, 88.1875);
vertex(284, 80.1875);
vertex(268, 73.1875);
vertex(257, 73.1875);
vertex(250, 70.1875);
vertex(237, 68.1875);
vertex(228, 69.1875);
vertex(233, 64.1875);
vertex(239, 61.1875);
vertex(247, 58.1875);
vertex(252, 57.1875);
vertex(258, 50.1875);
vertex(266, 44.1875);
vertex(278, 38.1875);
vertex(289, 33.1875);
vertex(301, 35.1875);
vertex(312, 37.1875);
vertex(323, 40.1875);
vertex(332, 43.1875);
vertex(345, 50.1875);
vertex(357, 57.1875);
vertex(363, 66.1875);
vertex(377, 85.1875);
vertex(378, 91.1875);
vertex(380, 96.1875);
vertex(383, 101.1875);
vertex(383, 107.1875);
vertex(382, 116.1875);
vertex(389, 123.1875);
vertex(394, 143.1875);
vertex(397, 162.1875);
vertex(396, 173.1875);
vertex(412, 218.1875);
vertex(422, 252.1875);
vertex(424, 261.1875);
vertex(428, 272.1875);
vertex(432, 281.1875);
vertex(435, 296.1875);
vertex(436, 312.1875);
vertex(446, 345.1875);
vertex(453, 373.1875);
vertex(462, 387.1875);
vertex(467, 409.1875);
vertex(470, 422.1875);
vertex(462, 434.1875);
vertex(451, 438.1875);
vertex(439, 438.1875);
vertex(429, 435.1875);
vertex(427, 440.1875);
vertex(421, 448.1875);
vertex(421, 455.1875);
vertex(418, 464.1875);
vertex(418, 464.1875);
vertex(408, 465.1875);
vertex(390, 467.1875);
vertex(380, 462.1875);
vertex(379, 450.1875);
vertex(378, 422.1875);
vertex(377, 388.1875);
vertex(376, 363.1875);
vertex(371, 346.1875);
vertex(372, 335.1875);
vertex(370, 320.1875);
vertex(369, 285.1875);
vertex(369, 253.1875);
vertex(365, 224.1875);
vertex(366, 214.1875);
vertex(365, 196.1875);
vertex(361, 179.1875);
vertex(359, 160.1875);
vertex(359, 160.1875);
vertex(356, 149.1875);
vertex(356, 141.1875);
vertex(356, 135.1875);
vertex(357, 126.1875);
vertex(357, 121.1875);
vertex(355, 95.1875);
endShape(CLOSE);
          break;

          case 'angry':
            // Cas per a l'emoci√≥ "angry" (enfadat)
            stroke(200, 50, 50);
            // Defineix el contorn en vermell intens (RGB: 200, 50, 50)
            fill(255, 100, 100, 200 * smoothIntensity);
            // Omple la forma amb un vermell m√©s suau, amb transpar√®ncia dependenta de la intensitat
            
            break;

          case 'surprised':
            // Cas per a l'emoci√≥ "surprised" (sorpr√®s)
            stroke(100, 200, 255);
            // Defineix el contorn amb un blau cel (RGB: 100, 200, 255)
            fill(200, 240, 255, 150 * smoothIntensity);
            // Omple la figura amb un blau molt clar, amb transpar√®ncia variable segons la intensitat
            const circles = 5 + floor(smoothIntensity * 8);
            // Calcula el nombre de cercles conc√®ntrics a dibuixar depenent de la intensitat
            for (let i = 0; i < circles; i++) {
              // Bucle per dibuixar cada cercle
              const radius = baseSize * (0.2 + i / circles);
              // Calcula el radi del cercle actual, augmentant gradualment amb cada iteraci√≥
              ellipse(centerX, centerY, radius * 2, radius * 2);
              // Dibuixa el cercle amb el di√†metre doble del radi
            }
            break;

          case 'disgusted':
            // Cas per a l'emoci√≥ "disgusted" (fastiguejat)
            stroke(100, 150, 50);
            // Defineix el contorn amb un to verd fosc (RGB: 100, 150, 50)
            fill(150, 200, 100, 150 * smoothIntensity);
            // Omple amb un verd suau, amb opacitat ajustada segons la intensitat
            beginShape();
            for (let i = 0; i < 8; i++) {
              // Bucle per generar 8 vertex per la forma
              const angle = map(i, 0, 8, 0, TWO_PI);
              // Distribueix 8 punts de manera uniforme al voltant del cercle
              const radius = baseSize * (0.5 + noise(t + i * 0.5) * 0.5);
              // Calcula el radi variable amb una combinaci√≥ de valor base i la funci√≥ noise() per crear irregularitats
              vertex(centerX + cos(angle) * radius, centerY + sin(angle) * radius);
              // Defineix cada vertex amb coordenades convertides de polars a cartesianes
            }
            endShape(CLOSE);
            break;

          default:
            // Cas per a qualsevol altra emoci√≥ (incl√≤s 'neutral')
            stroke(150);
            // Estableix el contorn amb un gris neutre (valor 150 de 0 a 255)
            fill(220, 220, 220, 100);
            // Omple amb un gris clar amb una opacitat suau
            rectMode(CENTER);
            // Indica que el rectangle es dibuixar√† centrat en el punt (centerX, centerY)
            const size = baseSize * 0.5;
            // Defineix la mida del rectangle com la meitat de la mida base
            rect(centerX, centerY, size, size, size * 0.2);
            // Dibuixa el rectangle amb cantonades arrodonides, on l'√∫ltim par√†metre controla l'arrodoniment
            break;
        }
      }

      //--------------------------------------------------
      // FUNCI√ì drawHUD
      //--------------------------------------------------
      function drawHUD() {
        // Aquesta funci√≥ dibuixa el Heads-Up Display que mostra un emoticon i el percentatge d'intensitat.
        const traduccions = {
          happy: "üòÉ Feli√ß",
          sad: "üò¢ Trist",
          angry: "üò° Enfadat",
          surprised: "üò≤ Sorpr√®s",
          disgusted: "ü§¢ Fastiguejat",
          neutral: "üòê Neutral",
          fearful: "üò® Espantat"
        };
        // Objecte que relaciona cada emoci√≥ amb un emoticon i text descriptiu en catal√†.
        const emoticon = traduccions[currentExpression.dominant] || "üòê Neutral";
        // Selecciona l'emoticon corresponent a l'expressi√≥ dominant; per defecte, "Neutral" si no hi ha coincid√®ncia.
        noStroke();
        // No s'aplica contorn al text.
        fill(50, 150, 255);
        // Defineix el color del text com un blau intens (RGB: 50, 150, 255).
        textSize(map(width, 300, 1200, 16, 24));
        // La mida del text s'ajusta en funci√≥ de l'amplada de la finestra, variant entre 16 i 24 p√≠xels.
        textAlign(CENTER, TOP);
        // Centra el text horitzontalment i l'alinea a la part superior del canvas.
        text(`${emoticon} (${floor(smoothIntensity * 100)}%)`, width / 2, 20);
        // Dibuixa el text al centre superior amb l'emoticon i el percentatge d'intensitat, calculat com smoothIntensity * 100 arrodonit cap avall.
      }

      //--------------------------------------------------
      // FUNCI√ì drawVideoPreview
      //--------------------------------------------------
      function drawVideoPreview() {
        // Aquesta funci√≥ dibuixa una petita previsualitzaci√≥ del v√≠deo de la c√†mera a la cantonada inferior dreta.
        const previewSize = min(width, height) * 0.15;
        // Calcula la mida de la previsualitzaci√≥ com el 15% de la mida m√≠nima (entre amplada i al√ßada) de la finestra.
        image(
          video,
          width - previewSize - 10,  /* Coordenada X: col¬∑loca la imatge a la dreta, deixant un marge de 10 p√≠xels */
          height - previewSize - 10, /* Coordenada Y: col¬∑loca la imatge a la part inferior amb un marge de 10 p√≠xels */
          previewSize,               /* Amplada de la previsualitzaci√≥ */
          previewSize                /* Al√ßada de la previsualitzaci√≥ */
        );
      }

      //--------------------------------------------------
      // GESTI√ì D'ERRORS AMB LA C√ÄMERA
      //--------------------------------------------------
      // Demana acc√©s a la c√†mera del dispositiu.
      navigator.mediaDevices.getUserMedia({ video: true })
        .catch(err => {
          // Si hi ha error (per exemple, si l'usuari denega l'acc√©s), actualitza la pantalla de c√†rrega per mostrar un missatge d'error.
          document.getElementById('loading-screen').innerHTML = `
            <p style="color: red; text-align: center">
              Error de c√†mera!<br>
              Permet l'acc√©s a la c√†mera i actualitza.
            </p>
          `;
        });
    </script>
  </body>
</html>
